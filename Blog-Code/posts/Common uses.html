<h1 id="common-uses">Common uses</h1><p>This document explains all the custom Markdown blocks and syntax extensions available in this blog system.</p>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-0">Table of Contents</h2><ol start="1">
<li><p><a href="#h2=connector%20block" >Connector Block</a></p>
</li>
<li><p><a href="#h2=grid%20system" >Grid System</a></p>
</li>
<li><p><a href="#h2=float%20elements" >Float Elements</a></p>
</li>
<li><p><a href="#h2=callouts" >Callouts (Note & Warning)</a></p>
</li>
<li><p><a href="#h2=Details/Summary" >Details/Summary</a></p>
</li>
<li><p><a href="#h2=iframe%20embedding" >Iframe Embedding</a></p>
</li>
<li><p><a href="#h2=spacing%20elements" >Spacing Elements</a></p>
</li>
<li><p><a href="#h2=Relative%20navigation%20link" >Relative navigation link</a></p>
</li>
</ol>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-1">Connector Block</h2><p>The <code class="language-">:::connector</code> block creates a visual file/folder tree structure with connecting lines, perfect for displaying hierarchical content like file systems.</p>
<h3 id="section-1-item-0">Features:</h3><ul>
<li><p>Nested lists with visual connectors</p>
</li>
<li><p>Support for emojis as icons</p>
</li>
<li><p>Escape icons with backslash if needed</p>
</li>
<li><p>Maintains indentation for nested items</p>
</li>
<li><p>Custom attributes support</p>
</li>
</ul>
<h3 id="section-1-item-1">Example:</h3><div class="content-connector" >

<ul>
<li data-icon="üìÑ"><p>file.txt</p>
</li>
<li data-icon="üìÑ"><p>File with<br>  super long name.bat</p>
</li>
<li data-icon="üìÇ"><p>Open folder</p>
  <div class="content-connector" >
  
<ul>
<li data-icon="üìÑ"><p>file inside.txt  </p>
</li>
<li data-icon="üìÑ"><p>other file.txt</p>
</li>
</ul>
  </div>
  </li>
<li data-icon="üìÅ"><p>folder</p>
</li>
<li><p>üìÉ escaped icon file.txt</p>
</li>
</ul>
</div>


<h3 id="section-1-item-2">Syntax:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::connector
    - üìÑ file.txt
    - üìÑ File with
        super long name.bat
    - üìÇ Open folder
        :::connector
            - üìÑ file inside.txt  
            - üìÑ other file.txt
        :::
    - üìÅ folder
    - \üìÉ escaped icon file.txt
:::</code></pre></div></p>
<h3 id="section-1-item-3">With Custom Attributes:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::connector style=&quot;max-width: 500px;&quot;
    - üìÑ Your content here
:::</code></pre></div></p>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-2">Grid System</h2><p>The <code class="language-">:::grid</code> block creates responsive grid layouts for organizing content in columns.</p>
<h3 id="section-2-item-0">Features:</h3><ul>
<li><p>Customizable number of columns</p>
</li>
<li><p>Adjustable gap spacing</p>
</li>
<li><p>Responsive design options</p>
</li>
<li><p>Auto-fit capabilities</p>
</li>
<li><p>Equal height items option</p>
</li>
<li><p>Custom styling support</p>
</li>
</ul>
<h3 id="section-2-item-1">Basic Grid:</h3><div class="markdown-grid grid-cols-2 gap-2" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; ">
<div class="grid-item">

<h3 id="section-2-item-2">Element 1</h3><p>Content for element 1. Replace with your own content.</p>
</div>
<div class="grid-item">

<h3 id="section-2-item-3">Element 2</h3><p>Content for element 2. Replace with your own content.</p>
<div class="markdown-grid grid-cols-2 gap-2" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; ">
<div class="grid-item">

<h3 id="section-2-item-4">Nested Element 1</h3><p>Content for nested element 1.</p>
</div>
<div class="grid-item">

<h3 id="section-2-item-5">Nested Element 2</h3><p>Content for nested element 2.</p>
</div>
</div>

</div>
</div>

<h3 id="section-2-item-6">Syntax:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::grid cols-2 gap-2
    ### Element 1

    Content for element 1. Replace with your own content.
    ---
    ### Element 2

    Content for element 2. Replace with your own content.

    :::grid cols-2 gap-2
        ### Nested Element 1

        Content for nested element 1.
        ---
        ### Nested Element 2

        Content for nested element 2.
    :::
:::</code></pre></div></p>
<h3 id="section-2-item-7">Configuration Options:</h3><ul>
<li><p><strong><code class="language-">cols-N</code></strong>: Number of columns (e.g., <code class="language-">cols-2</code>, <code class="language-">cols-3</code>, <code class="language-">cols-4</code>)</p>
</li>
<li><p><strong><code class="language-">gap-N</code></strong>: Gap size between items (e.g., <code class="language-">gap-2</code>, <code class="language-">gap-4</code>)</p>
</li>
<li><p><strong><code class="language-">responsive</code></strong>: Makes grid responsive to screen size</p>
</li>
<li><p><strong><code class="language-">auto-fit</code></strong>: Automatically fits columns based on content</p>
</li>
<li><p><strong><code class="language-">min-N</code></strong>: Minimum width for auto-fit (e.g., <code class="language-">min-250</code>)</p>
</li>
<li><p><strong><code class="language-">equal-height</code></strong>: Makes all grid items equal height</p>
</li>
<li><p><strong><code class="language-">style=&quot;...&quot;</code></strong>: Add custom CSS styles</p>
</li>
</ul>
<h3 id="section-2-item-8">Examples:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown"># Responsive grid with auto-fit
:::grid auto-fit min-300 gap-3 responsive
    Content 1
    ---
    Content 2
    ---
    Content 3
:::

# 3-column grid with custom styles
:::grid cols-3 gap-4 style=&quot;padding: 20px; background: #f0f0f0;&quot;
    Column 1
    ---
    Column 2
    ---
    Column 3
:::

# Equal height items
:::grid cols-2 gap-2 equal-height
    Short content
    ---
    Much longer content that would normally make this item taller
:::</code></pre></div></p>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-3">Float Elements</h2><p>Float elements are floating panels that can be triggered anywhere in the content, perfect for tooltips, additional information, or expandable content.</p>
<h3 id="section-3-item-0">Creating a Float Element:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::float-myid
    This is the content that will appear in the floating panel.

    You can include **any markdown** here, including:
    - Lists
    - Images
    - Code blocks
    - etc.
:::</code></pre></div></p>
<h3 id="section-3-item-1">Triggering the Float Element:</h3><p>Use the syntax <code class="language-">(?=id)</code> anywhere in your content to create a trigger button:</p>
<p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">This is some text with a question mark (?=myid) that opens more info.</code></pre></div></p>
<h3 id="section-3-item-2">Features:</h3><ul>
<li><p>Click trigger to open/close</p>
</li>
<li><p>Click close button (√ó) to dismiss</p>
</li>
<li><p>Click outside to close</p>
</li>
<li><p>Multiple float elements per page</p>
</li>
<li><p>Supports full markdown inside</p>
</li>
</ul>
<h3 id="section-3-item-3">Complete Example:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown"># My Article

This is a paragraph with more information available (?=details).

:::float-details
    ### Additional Details

    Here&#039;s some extra information that doesn&#039;t fit in the main text:
    - Point 1
    - Point 2
    - Point 3
:::</code></pre></div></p>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-4">Callouts</h2><p>Callouts are styled boxes to highlight important information. Two types are available: <strong>Note</strong> and <strong>Warning</strong>.</p>
<h3 id="section-4-item-0">Note Callout:</h3><div class="note-callout">
<div class="callout-header">
<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 20H7.197c-1.118 0-1.678 0-2.105-.218a2 2 0 0 1-.874-.874C4 18.48 4 17.92 4 16.8V7.2c0-1.12 0-1.68.218-2.108c.192-.377.497-.682.874-.874C5.52 4 6.08 4 7.2 4h9.6c1.12 0 1.68 0 2.107.218c.377.192.683.497.875.874c.218.427.218.987.218 2.105V13m-7 7c.286-.003.466-.014.639-.055q.308-.075.578-.24c.202-.124.375-.296.72-.642l4.126-4.125c.346-.346.518-.52.642-.721q.165-.271.24-.579c.04-.172.051-.352.054-.638M13 20v-5.4c0-.56 0-.84.109-1.054a1 1 0 0 1 .437-.437C13.76 13 14.04 13 14.6 13H20"/></svg>
<span>Note</span>
</div>
<div class="callout-content">

<p>This is important information that readers should be aware of.<br>You can include any markdown content here.</p>
</div>
</div>

<p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::note
    This is important information that readers should be aware of.
    You can include any markdown content here.
:::</code></pre></div></p>
<h3 id="section-4-item-1">Warning Callout:</h3><div class="warning-callout">
<div class="callout-header">
<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M12 12.5ZM2.725 21q-.575 0-.85-.537T1.8 19.4l9.2-16q.275-.5.75-.7t.95 0t.75.7l9.2 16q.275.5.075 1.063T21.9 21zm1.85-2h14.85L12 5zm7.425-1q.425 0 .713-.288T13 17q0-.425-.288-.713T12 16q-.425 0-.713.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.713T12 10q-.425 0-.713.288T11 11v3q0 .425.288.713T12 15"></path></svg>
<span>Warning</span>
</div>
<div class="callout-content">

<p>This is a critical warning that requires attention.<br>Be careful with this information!</p>
</div>
</div>

<p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::warning
    This is a critical warning that requires attention.
    Be careful with this information!
:::</code></pre></div></p>
<h3 id="section-4-item-2">Features:</h3><ul>
<li><p>Icon and header automatically added</p>
</li>
<li><p>Supports nested markdown</p>
</li>
<li><p>Distinct styling for each type</p>
</li>
<li><p>Can contain any markdown content</p>
</li>
</ul>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-5">Details/Summary</h2><p>Collapsible sections that hide content until clicked.</p>
<h3 id="section-5-item-0">Basic Details:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::details Click to expand
    This content is hidden by default and will show when clicked.

    You can include:
    - Lists
    - **Formatted text**
    - Code blocks
    - Anything else
:::</code></pre></div></p>
<h3 id="section-5-item-1">Open by Default:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::details -open Already expanded
    This content is visible by default but can be collapsed.
:::</code></pre></div></p>
<h3 id="section-5-item-2">Features:</h3><ul>
<li><p>Collapsible content sections</p>
</li>
<li><p>Custom summary text</p>
</li>
<li><p>Option to start expanded with <code class="language-">-open</code></p>
</li>
<li><p>Supports full markdown inside</p>
</li>
<li><p>Nested details supported</p>
</li>
</ul>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-6">Iframe Embedding</h2><p>Embed external content with an expandable viewer.</p>
<h3 id="section-6-item-0">Syntax:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::iframe width=&quot;100%&quot; height=&quot;500px&quot;
https://example.com
:::</code></pre></div></p>
<h3 id="section-6-item-1">Features:</h3><ul>
<li><p>Custom width and height attributes</p>
</li>
<li><p>Expand/contract button automatically added</p>
</li>
<li><p>Fullscreen capability</p>
</li>
<li><p>Any valid iframe attributes supported</p>
</li>
</ul>
<h3 id="section-6-item-2">Example with Multiple Attributes:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">:::iframe width=&quot;800px&quot; height=&quot;600px&quot; allow=&quot;fullscreen&quot;
https://www.youtube.com/embed/VIDEO_ID
:::</code></pre></div></p>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-7">Spacing Elements</h2><p>Add precise spacing to your content.</p>
<h3 id="section-7-item-0">Width Spacing:</h3><p>Adds horizontal spacing:</p>
<p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">Text before (w=2em) text after</code></pre></div></p>
<p>Creates a <code class="language-">&lt;div&gt;</code> with the specified width.</p>
<h3 id="section-7-item-1">Height Spacing:</h3><p>Adds vertical spacing:</p>
<p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">Paragraph 1

(h=3rem)

Paragraph 2</code></pre></div></p>
<p>Creates a <code class="language-">&lt;div&gt;</code> with the specified height.</p>
<h3 id="section-7-item-2">Supported Units:</h3><ul>
<li><p><code class="language-">px</code> - pixels</p>
</li>
<li><p><code class="language-">em</code> - relative to font size</p>
</li>
<li><p><code class="language-">rem</code> - relative to root font size</p>
</li>
<li><p><code class="language-">lh</code> - line height</p>
</li>
</ul>
<h3 id="section-7-item-3">Examples:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown"># Add 50px horizontal space
Before (w=50px) After

# Add 2em vertical space
Top paragraph

(h=2em)

Bottom paragraph

# Add 1 line-height space
Content

(h=1lh)

More content</code></pre></div></p>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-8">Relative navigation link</h2><p>Special navigation elements that create relative links with directional movement.</p>
<h3 id="section-8-item-0">Syntax:</h3><p>Put the link using:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">[Link Name](#goto=&lt;DIRECTION&gt;)</code></pre></div></p>
<p>Put where it leads (makes focus) using:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">(go-&lt;DIRECTION&gt;=element-name)</code></pre></div></p>
<h3 id="section-8-item-1">Available Directions:</h3><ul>
<li><p><strong><code class="language-">out</code></strong>: Navigate to parent element</p>
</li>
<li><p><strong><code class="language-">above</code></strong>: Navigate to previous sibling</p>
</li>
<li><p><strong><code class="language-">below</code></strong>: Navigate to next sibling</p>
</li>
<li><p><strong><code class="language-">in</code></strong>: Navigate to first child</p>
</li>
<li><p><strong><code class="language-">inl</code></strong>: Navigate to last child</p>
</li>
</ul>
<h3 id="section-8-item-2">Stacking Directions:</h3><p>You can chain multiple directions together:</p>
<p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown"># Go out twice then down
(go-out-out-bellow=section-name)

# Go out, then to previous sibling
(go-out-above=header-title)

# Enter first child
(go-in=first-item)</code></pre></div></p>
<h3 id="section-8-item-3">Examples:</h3><p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown">[Navigate to parent&#039;s next sibling with](#goto=next-topic)
See the next section (go-out-bellow=next-topic)

[Navigate up one level then to previous](#goto=previous-section)
Go back to previous (go-out-above=previous-section)

[Navigate to first child of next sibling](#goto=item-list)
Check the first item (go-bellow-in=item-list)</code></pre></div></p>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-9">Additional Notes</h2><h3 id="section-9-item-0">Nesting Blocks:</h3><p>Most blocks support nesting. Common patterns:</p>
<p><div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre><code class="language-markdown"># Grid inside Note
:::note
    Important grid layout:
    :::grid cols-2 gap-2
        Item 1
        ---
        Item 2
    :::
:::

# Connector inside Grid
:::grid cols-2
    :::connector
        - File 1
        - File 2
    :::
    ---
    Other content
:::

# Details with Float triggers
:::details More Information
    Click here for details (?=extra-info)

    :::float-extra-info
        Even more detailed information
    :::
:::</code></pre></div></p>
<h3 id="section-9-item-1">Indentation:</h3><p>The system automatically removes common indentation from block content, so you can indent for readability in your source files without affecting the output.<br>In some cases, such as lists and connectors within lists, indentation is mandatory for correct operation.</p>
<h3 id="section-9-item-2">Markdown Processing:</h3><p>All block contents are processed for markdown, so you can use:</p>
<ul>
<li><p><strong>Bold</strong>, <em>italic</em>, <code class="language-">code</code></p>
</li>
<li><p>Lists and sublists</p>
</li>
<li><p>Links and images</p>
</li>
<li><p>Code blocks</p>
</li>
<li><p>Other custom blocks</p>
</li>
</ul>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-10">Tips and Best Practices</h2><ol start="1">
<li><p><strong>Use semantic names</strong>: When creating float IDs or navigation targets, use descriptive names like <code class="language-">detailed-explanation</code> instead of <code class="language-">float1</code>.</p>
</li>
<li><p><strong>Grid responsiveness</strong>: For mobile-friendly layouts, use <code class="language-">responsive</code> and <code class="language-">auto-fit</code> options with reasonable <code class="language-">min-</code> values.</p>
</li>
<li><p><strong>Callout usage</strong>: Use <code class="language-">:::note</code> for helpful information and <code class="language-">:::warning</code> for critical warnings or potential issues.</p>
</li>
<li><p><strong>Spacing consistency</strong>: Use <code class="language-">rem</code> or <code class="language-">em</code> units for spacing to maintain consistency with your design system.</p>
</li>
<li><p><strong>Navigation links</strong>: Test your navigation links thoroughly as they depend on the rendered HTML structure.</p>
</li>
<li><p><strong>Float elements position</strong>: Float elements work best with short, clickable trigger text. Don&#39;t overuse them in a single paragraph.</p>
</li>
</ol>
<p><rawhtml><br></rawhtml></p>
<hr>
<p><rawhtml><br></rawhtml></p>
<h2 id="section-11">Quick Reference</h2><table>
<thead>
<tr>
<th>Block Type</th>
<th>Syntax</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>Connector</td>
<td><code class="language-">:::connector</code></td>
<td>File/folder trees</td>
</tr>
<tr>
<td>Grid</td>
<td><code class="language-">:::grid cols-N gap-N</code></td>
<td>Multi-column layouts</td>
</tr>
<tr>
<td>Float</td>
<td><code class="language-">:::float-&lt;id&gt;</code> + <code class="language-">(?=&lt;id&gt;)</code></td>
<td>Floating panels/tooltips</td>
</tr>
<tr>
<td>Note</td>
<td><code class="language-">:::note</code></td>
<td>Information callouts</td>
</tr>
<tr>
<td>Warning</td>
<td><code class="language-">:::warning</code></td>
<td>Warning callouts</td>
</tr>
<tr>
<td>Details</td>
<td><code class="language-">:::details &lt;Title&gt;</code></td>
<td>Collapsible sections</td>
</tr>
<tr>
<td>Iframe</td>
<td><code class="language-">:::iframe</code></td>
<td>Embedded content</td>
</tr>
<tr>
<td>Width spacing</td>
<td><code class="language-">(w=&lt;AMOUNT&gt;&lt;UNIT&gt;)</code></td>
<td>Horizontal space</td>
</tr>
<tr>
<td>Height spacing</td>
<td><code class="language-">(h=&lt;AMOUNT&gt;&lt;UNIT&gt;)</code></td>
<td>Vertical space</td>
</tr>
<tr>
<td>Navigation</td>
<td><code class="language-">(go-&lt;DIR&gt;=&lt;name&gt;)</code></td>
<td>Relative navigation</td>
</tr>
<tr>
<td>Internal links</td>
<td><code class="language-">[&lt;text&gt;](&lt;#link&gt;)</code></td>
<td>Auto-encoded links</td>
</tr>
</tbody></table>
<script id="entry-script">

        /* Make it scroll slowly with special functionalities */
        document.querySelectorAll("a").forEach((link) => {
            link.addEventListener("click", function (e) {
                const href = this.getAttribute("href") || this.getAttribute("xlink:href");
                
                // Only process if it's an internal link (starts with #)
                if (href && href.startsWith("#")) {
                    e.preventDefault(); // prevents instant jump

                    let target = null;
                    const entryContent = document.querySelector('.entry-content');
                    let targetId = href.substring(1); // substring removes the "#"
                    
                    targetId = decodeURIComponent(targetId);
                    
                    // Check if it's a special link with parameters
                    if (targetId.includes('=')) {
                        
                        // Use indexOf to properly handle values with spaces or special characters
                        const equalIndex = targetId.indexOf('=');
                        const type = targetId.substring(0, equalIndex);
                        const value = targetId.substring(equalIndex + 1);
                        
                        if (type.match(/^h[1-6]$/)) {
                            // Search by position or by text in the specified h type
                            const headingLevel = parseInt(type.substring(1));
                            
                            if (headingLevel >= 1 && headingLevel <= 6) {
                                const headings = entryContent ? 
                                    entryContent.querySelectorAll(`h${headingLevel}`) : 
                                    document.querySelectorAll(`h${headingLevel}`);
                                
                                if (!isNaN(value)) {
                                    // Search by position (e.g. #h2=3 searches for the third h2)
                                    const elementIndex = parseInt(value) - 1; // Convert to 0-based index
                                    if (elementIndex >= 0 && headings.length > elementIndex) {
                                        target = headings[elementIndex];
                                    }
                                } else {
                                    // Search by text (e.g. #h2=Introduction searches for the first h2 containing "Introduction")
                                    const searchText = decodeURIComponent(value);
                                    target = Array.from(headings).find(heading => 
                                        heading.textContent.toLowerCase().includes(searchText.toLowerCase())
                                    );
                                }
                            }
                        } else if (type === 'text') {
                            const searchText = decodeURIComponent(value);
                            const searchArea = entryContent || document;

                            // Find all elements in order
                            const allElements = Array.from(searchArea.querySelectorAll('*'));

                            let firstMatch = null;
                            for (const element of allElements) {
                                if (element.textContent.includes(searchText)) {
                                    firstMatch = element;
                                    break; // we stop at the first one that contains the text
                                }
                            }

                            target = firstMatch;

                            // If we found something, we look for the deepest one inside it
                            if (firstMatch) {
                                // Recursive function to find the most nested element that contains the text
                                const findDeepestMatch = (el) => {
                                    for (const child of el.children) {
                                        if (child.textContent.includes(searchText)) {
                                            // Search deeper in that child
                                            return findDeepestMatch(child);
                                        }
                                    }
                                    return el;
                                };

                                target = findDeepestMatch(firstMatch);
                            }
                        } else if (type === 'query') {
                            // Execute custom querySelector (e.g. #query=document.querySelector("selector"))
                            try {
                                const queryString = decodeURIComponent(value);
                                // Evaluate the query safely
                                target = eval(queryString);
                            } catch (error) {
                                console.warn('Error executing query selector:', error);
                                target = null;
                            }
                        } else if (type === 'goto') {

                            const queryString = decodeURIComponent(value);

                            // Helper function to check if element is visible
                            const isElementVisible = (element) => {
                                if (!element) return false;
                                const style = window.getComputedStyle(element);
                                const rect = element.getBoundingClientRect();
                                return style.display !== 'none' && 
                                       style.visibility !== 'hidden' && 
                                       style.opacity !== '0' &&
                                       rect.width > 0 && 
                                       rect.height > 0;
                            };

                            // Helper function to find visible parent
                            const findVisibleParent = (element) => {
                                let parent = element.parentElement;
                                while (parent) {
                                    if (isElementVisible(parent)) {
                                        return parent;
                                    }
                                    parent = parent.parentElement;
                                }
                                
                                // If no visible parent found, check if parent node contains text nodes
                                // and wrap them if needed (for cases where element is inside text)
                                let parentNode = element.parentNode;
                                if (parentNode && parentNode.nodeType === Node.ELEMENT_NODE) {
                                    // Check child nodes for text content
                                    for (let node of parentNode.childNodes) {
                                        if (node !== element && node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                                            // Found text node sibling, wrap parent's content
                                            const wrapper = document.createElement('div');
                                            wrapper.style.display = 'inline-block';
                                            
                                            // Move all child nodes to wrapper
                                            while (parentNode.firstChild) {
                                                wrapper.appendChild(parentNode.firstChild);
                                            }
                                            
                                            parentNode.appendChild(wrapper);
                                            return wrapper;
                                        }
                                    }
                                }
                                
                                return null;
                            };

                            // Helper function to find visible previous sibling
                            const findVisiblePreviousSibling = (element) => {
                                // Start directly with previousSibling to catch both elements and text nodes
                                let prevNode = element.previousSibling;
                                while (prevNode) {
                                    // Check if it's a text node with actual content (not just whitespace)
                                    if (prevNode.nodeType === Node.TEXT_NODE && prevNode.textContent.trim()) {
                                        // Wrap the text node in a span element
                                        const wrapper = document.createElement('span');
                                        wrapper.textContent = prevNode.textContent;
                                        prevNode.parentNode.replaceChild(wrapper, prevNode);
                                        return wrapper;
                                    }
                                    // If it's an element, check if it's visible
                                    if (prevNode.nodeType === Node.ELEMENT_NODE && isElementVisible(prevNode)) {
                                        return prevNode;
                                    }
                                    prevNode = prevNode.previousSibling;
                                }
                                
                                return null;
                            };

                            // Helper function to find visible next sibling
                            const findVisibleNextSibling = (element) => {
                                // Start directly with nextSibling to catch both elements and text nodes
                                let nextNode = element.nextSibling;

                                while (nextNode) {
                                    // Check if it's a text node with actual content (not just whitespace)
                                    if (nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent.trim()) {
                                        // Wrap the text node in a span element
                                        const wrapper = document.createElement('span');
                                        wrapper.textContent = nextNode.textContent;
                                        nextNode.parentNode.replaceChild(wrapper, nextNode);
                                        return wrapper;
                                    }
                                    // If it's an element, check if it's visible
                                    if (nextNode.nodeType === Node.ELEMENT_NODE && isElementVisible(nextNode)) {
                                        return nextNode;
                                    }
                                    nextNode = nextNode.nextSibling;
                                }
                                
                                return null;
                            };

                            // Helper function to find first visible child (enter element)
                            const findVisibleFirstChild = (element) => {
                                // Start with first child to catch both elements and text nodes
                                let firstNode = element.firstChild;
                                
                                while (firstNode) {
                                    // Check if it's a text node with actual content (not just whitespace)
                                    if (firstNode.nodeType === Node.TEXT_NODE && firstNode.textContent.trim()) {
                                        // Wrap the text node in a span element
                                        const wrapper = document.createElement('span');
                                        wrapper.textContent = firstNode.textContent;
                                        firstNode.parentNode.replaceChild(wrapper, firstNode);
                                        return wrapper;
                                    }
                                    // If it's an element, check if it's visible
                                    if (firstNode.nodeType === Node.ELEMENT_NODE && isElementVisible(firstNode)) {
                                        return firstNode;
                                    }
                                    firstNode = firstNode.nextSibling;
                                }
                                
                                return null;
                            };

                            // Helper function to find last visible child (enter element at end)
                            const findVisibleLastChild = (element) => {
                                // Start with last child to catch both elements and text nodes
                                let lastNode = element.lastChild;
                                
                                while (lastNode) {
                                    // Check if it's a text node with actual content (not just whitespace)
                                    if (lastNode.nodeType === Node.TEXT_NODE && lastNode.textContent.trim()) {
                                        // Wrap the text node in a span element
                                        const wrapper = document.createElement('span');
                                        wrapper.textContent = lastNode.textContent;
                                        lastNode.parentNode.replaceChild(wrapper, lastNode);
                                        return wrapper;
                                    }
                                    // If it's an element, check if it's visible
                                    if (lastNode.nodeType === Node.ELEMENT_NODE && isElementVisible(lastNode)) {
                                        return lastNode;
                                    }
                                    lastNode = lastNode.previousSibling;
                                }
                                
                                return null;
                            };

                            // Helper function to apply a single navigation direction
                            const applyDirection = (currentElement, direction) => {
                                switch(direction) {
                                    case 'out':
                                        return findVisibleParent(currentElement);
                                    case 'above':
                                        return findVisiblePreviousSibling(currentElement);
                                    case 'below':
                                        return findVisibleNextSibling(currentElement);
                                    case 'in':
                                        return findVisibleFirstChild(currentElement);
                                    case 'inl':
                                        return findVisibleLastChild(currentElement);
                                    default:
                                        console.warn('Unknown direction:', direction);
                                        return null;
                                }
                            };

                            // Search for all go-navigate elements (new unified class)
                            const goNavigateElements = document.querySelectorAll('.go-navigate');
                            for (const element of goNavigateElements) {
                                if (element.getAttribute('data-name') === queryString) {
                                    const directionsStr = element.getAttribute('data-directions');
                                    const directions = directionsStr.split('-'); // Split "out-out-below" into ["out", "out", "below"]
                                    
                                    // Apply each direction in sequence
                                    let currentTarget = element;
                                    for (const direction of directions) {
                                        currentTarget = applyDirection(currentTarget, direction);
                                        if (!currentTarget) {
                                            console.warn('Navigation failed at direction:', direction);
                                            break;
                                        }
                                    }
                                    
                                    if (currentTarget) {
                                        target = currentTarget;
                                        break;
                                    }
                                }
                            }

                            if (!target) {
                                console.warn('No visible target found for goto:', queryString);
                            }
                        }
                    } else {
                        // Normal search by ID
                        target = document.getElementById(targetId);
                    }

                    if (target) {
                        // Detect which element handles the scroll
                        const entryContent = document.getElementsByClassName('entry-content')[0];
                        let container = null;
                        let isBodyScroll = false;
                        
                        // Check if entry-content exists and has scrolling
                        if (entryContent) {
                            const hasScroll = entryContent.scrollHeight > entryContent.clientHeight;
                            const hasOverflow = window.getComputedStyle(entryContent).overflowY !== 'visible';
                            
                            if (hasScroll && hasOverflow) {
                                container = entryContent;
                            }
                        }
                        
                        // If no scrollable container found, use body/document
                        if (!container) {
                            container = document.scrollingElement || document.documentElement;
                            isBodyScroll = true;
                        }
                        
                        // Calculate scroll position
                        if (container) {
                            const targetRect = target.getBoundingClientRect();
                            
                            let scrollTop;
                            if (isBodyScroll) {
                                // For body scroll: calculate from top of page
                                const targetTop = targetRect.top + window.scrollY;
                                const viewportHeight = window.innerHeight;
                                scrollTop = targetTop - viewportHeight / 2 + targetRect.height / 2;
                            } else {
                                // For container scroll: calculate relative to container
                                const containerRect = container.getBoundingClientRect();
                                const relativeTop = targetRect.top - containerRect.top + container.scrollTop;
                                scrollTop = relativeTop - container.clientHeight / 2 + targetRect.height / 2;
                            }
                            
                            // Perform scroll
                            container.scrollTo({
                                top: Math.max(0, scrollTop),
                                behavior: 'smooth'
                            });
                        }

                        // Wait for scroll to finish and element to be visible
                        const applyHighlight = () => {
                            if (window.highlightTargetTimeoutOut) clearTimeout(window.highlightTargetTimeoutOut);

                            // Clear previous animations from all elements
                            document.querySelectorAll('[style*="animation"]').forEach(el => {
                                if (el.style.animation.includes('targetZoom')) {
                                    el.style.animation = '';
                                }
                            });
                            
                            // Force reflow to ensure animation restarts
                            void target.offsetWidth;
                            
                            // Add highlighting animation
                            target.style.animation = 'targetZoom 1.5s ease-out';
                            
                            // Remove animation after completion
                            window.highlightTargetTimeoutOut = setTimeout(() => {
                                target.style.animation = '';
                            }, 1500);
                        };

                        // Detect when scroll ends
                        let observer;
                        let observerTimeout;

                        const onScrollEnd = (event) => {
                            if (observerTimeout) clearTimeout(observerTimeout);
                            observer?.disconnect();
                        
                            // Check if element is visible in viewport
                            const targetRect = target.getBoundingClientRect();
                            let containerRect;
                            
                            if (isBodyScroll) {
                                containerRect = { top: 0, bottom: window.innerHeight };
                            } else {
                                containerRect = container.getBoundingClientRect();
                            }
                            
                            const isVisible = targetRect.top < containerRect.bottom && targetRect.bottom > containerRect.top;
                            
                            if (isVisible) {
                                // Element is visible, apply highlight
                                if (event) {
                                    if (isBodyScroll) {
                                        window.removeEventListener(event, onScrollEnd);
                                    } else {
                                        container.removeEventListener(event, onScrollEnd);
                                    }
                                }
                                applyHighlight();
                            } else {
                                // Element is not visible yet, use IntersectionObserver
                                if (event) {
                                    if (isBodyScroll) {
                                        window.removeEventListener(event, onScrollEnd);
                                    } else {
                                        container.removeEventListener(event, onScrollEnd);
                                    }
                                }
                                
                                observer = new IntersectionObserver((entries) => {
                                    entries.forEach(entry => {
                                        if (entry.isIntersecting) {
                                            observer.disconnect();
                                            applyHighlight();
                                        }
                                    });
                                }, {
                                    root: isBodyScroll ? null : container,
                                    threshold: 0.1
                                });
                                
                                observer.observe(target);
                                
                                // Cleanup observer after 5 seconds if element never becomes visible
                                observerTimeout = setTimeout(() => {
                                    observer?.disconnect();
                                }, 5000);
                            }
                        };
                        
                        if (container) {
                            const scrollTarget = isBodyScroll ? window : container;
                            if ('onscrollend' in document.documentElement) {
                                scrollTarget.addEventListener('scrollend', onScrollEnd('scrollend'));
                            } else {
                                scrollTarget.addEventListener('scroll', onScrollEnd('scroll'));
                            }
                            // Trigger once immediately in case scroll doesn't happen
                            onScrollEnd();
                        }
                    }
                }
            });
        });
    
        // Remover listener anterior del documento si existe
        if (window.detailsClickHandler) {
            document.removeEventListener('click', window.detailsClickHandler);
        }

        // Crear el handler
        window.detailsClickHandler = function(e) {
            const details = e.target.closest('details');
            if (!details) return;
            
            const summary = e.target.closest('summary');
            if (!summary) return;
            
            const contentWrapper = details.querySelector('.content-wrapper-details');
            if (!contentWrapper) return;
            
            e.preventDefault();
            
            if (details.open) {
                // Close with animation
                contentWrapper.classList.add('animating');
                contentWrapper.classList.remove('opening');
                
                setTimeout(() => {
                    details.open = false;
                    contentWrapper.classList.remove('animating');
                }, 400);
            } else {
                // Open with animation
                details.open = true;
                contentWrapper.classList.add('animating');
                
                // Forzar reflow
                contentWrapper.offsetHeight;
                
                contentWrapper.classList.add('opening');
                
                setTimeout(() => {
                    contentWrapper.classList.remove('animating');
                }, 400);
            }
        };

        // Agregar un solo listener al documento
        document.addEventListener('click', window.detailsClickHandler);
        
        // Inicializar estado de contenido ya abierto
        document.querySelectorAll('details[open]').forEach(details => {
            const contentWrapper = details.querySelector('.content-wrapper-details');
            contentWrapper.classList.add('opening');
        });
    
    // Clean previous event listeners if they exist
    if (window.floatEventListeners) {
        if (window.floatEventListeners.triggerClick) {
            window.floatEventListeners.triggerClick.forEach(item => {
                item.element.removeEventListener('click', item.handler);
            });
        }
        if (window.floatEventListeners.documentClick) {
            document.removeEventListener('click', window.floatEventListeners.documentClick);
        }
        if (window.floatEventListeners.documentKeydown) {
            document.removeEventListener('keydown', window.floatEventListeners.documentKeydown);
        }
    }
    
    // Inicializar el objeto para almacenar los event listeners
    window.floatEventListeners = {
        triggerClick: [],
        documentClick: null,
        documentKeydown: null,
        activeFloats: new Set()
    };
    
    // Manejar los elementos flotantes
    document.querySelectorAll('.float-trigger').forEach(trigger => {
        const clickHandler = function() {
            const floatId = this.getAttribute('data-float-id');
            const floatContainer = document.getElementById('float-' + floatId);
            
            if (!floatContainer) return;
            
            // If the container is already visible, we close it
            if (floatContainer.classList.contains('visible')) {
                floatContainer.classList.remove('visible');
                window.floatEventListeners.activeFloats.delete(floatId);
                return;
            }
            
            // Close all floating containers that are open
            document.querySelectorAll('.float-container.visible').forEach(container => {
                container.classList.remove('visible');
                const openFloatId = container.id.replace('float-', '');
                window.floatEventListeners.activeFloats.delete(openFloatId);
            });
            
            // Mostrar el contenedor
            floatContainer.classList.add('visible');
            void floatContainer.offsetWidth; // reflow force before measuring
            window.floatEventListeners.activeFloats.add(floatId);
            
            const triggerRect = this.getBoundingClientRect();
            const parentRect = floatContainer.offsetParent.getBoundingClientRect();
            
            // Find the scrollable container (entry-content or closest scrollable parent)
            let scrollContainer = this.closest('.entry-content');
            if (!scrollContainer) {
                scrollContainer = this.closest('[style*="overflow"]') || document.documentElement;
            }
            
            // Get scroll offsets
            const scrollLeft = scrollContainer.scrollLeft || 0;
            const scrollTop = scrollContainer.scrollTop || 0;

            let left = triggerRect.left - parentRect.left + scrollLeft;
            let top  = triggerRect.bottom - parentRect.top + scrollTop + 10;

            const floatWidth = floatContainer.offsetWidth;
            const floatHeight = floatContainer.offsetHeight;
            const parentWidth = floatContainer.offsetParent.clientWidth;
            const parentHeight = floatContainer.offsetParent.clientHeight;

            // Ajustar horizontal
            if (left + floatWidth > parentWidth - 10) {
                left = parentWidth - floatWidth - 10;
            }
            if (left < 0) {
                left = 0;
            }

            // Ajustar vertical - considerar tanto el viewport del contenedor con scroll como el viewport de la ventana
            const scrollContainerRect = scrollContainer.getBoundingClientRect();
            const triggerBottomRelativeToScroll = triggerRect.bottom - scrollContainerRect.top;
            const availableSpaceInContainer = scrollContainer.clientHeight - triggerBottomRelativeToScroll;
            
            // Tambi√©n verificar si se sale del viewport de la ventana
            const availableSpaceInWindow = window.innerHeight - triggerRect.bottom;
            
            // Si el contenedor tiene scroll, usar su espacio disponible, sino usar el de la ventana
            const hasContainerScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;
            const shouldCheckContainer = hasContainerScroll && scrollContainer !== document.documentElement;
            
            let shouldPlaceAbove = false;
            if (shouldCheckContainer) {
                // El contenedor tiene scroll, verificar espacio en el contenedor
                shouldPlaceAbove = availableSpaceInContainer < floatHeight + 50;
            } else {
                // El contenedor no tiene scroll, verificar espacio en la ventana
                shouldPlaceAbove = availableSpaceInWindow < floatHeight + 50;
            }
            
            if (shouldPlaceAbove) {
                // si no cabe debajo, col√≥calo arriba del trigger
                top = triggerRect.top - parentRect.top + scrollTop - floatHeight - 10;
            }

            // Asegurar que no se salga por arriba
            const minTop = shouldCheckContainer ? scrollTop + 10 : 10;
            if (top < minTop) {
                top = minTop;
            }
            
            // Asegurar que no se salga por abajo del viewport de la ventana
            if (!shouldCheckContainer) {
                const maxTop = window.innerHeight - floatHeight - 20;
                const currentTopInViewport = top - scrollTop + parentRect.top;
                if (currentTopInViewport > maxTop) {
                    top = maxTop + scrollTop - parentRect.top;
                }
            }

            floatContainer.style.left = left + "px";
            floatContainer.style.top = top + "px";
        };
        
        trigger.addEventListener('click', clickHandler);
        window.floatEventListeners.triggerClick.push({
            element: trigger,
            handler: clickHandler
        });
    });
    
    // Cerrar los elementos flotantes al hacer clic fuera
    const documentClickHandler = function(e) {
        if (e.target.classList.contains('float-close')) {
            const container = e.target.closest('.float-container');
            if (container) {
                container.classList.remove('visible');
                const floatId = container.id.replace('float-', '');
                window.floatEventListeners.activeFloats.delete(floatId);
            }
        } else if (!e.target.closest('.float-container') && !e.target.closest('.float-trigger')) {
            document.querySelectorAll('.float-container.visible').forEach(container => {
                container.classList.remove('visible');
                const floatId = container.id.replace('float-', '');
                window.floatEventListeners.activeFloats.delete(floatId);
            });
        }
    };
    
    document.addEventListener('click', documentClickHandler);
    window.floatEventListeners.documentClick = documentClickHandler;
    
    // Cerrar con ESC
    const documentKeydownHandler = function(e) {
        if (e.key === 'Escape') {
            document.querySelectorAll('.float-container.visible').forEach(container => {
                container.classList.remove('visible');
                const floatId = container.id.replace('float-', '');
                window.floatEventListeners.activeFloats.delete(floatId);
            });
        }
    };
    
    document.addEventListener('keydown', documentKeydownHandler);
    window.floatEventListeners.documentKeydown = documentKeydownHandler;
    
    // Global method to close all floating elements
    window.closeAllFloats = function() {
        document.querySelectorAll('.float-container.visible').forEach(container => {
            container.classList.remove('visible');
        });
        window.floatEventListeners.activeFloats.clear();
    };
    // Select the first element with class "entry-content"
    const entryContent = document.querySelector('.entry-content');

    if (entryContent) {
        // Select all <script> elements within that element
        const scripts = entryContent.querySelectorAll('script');

        scripts.forEach(oldScript => {
            try {
                // Create a new script element to execute
                const newScript = document.createElement('script');

                // Copy attributes (e.g., src, type, etc.)
                Array.from(oldScript.attributes).forEach(attr => {
                newScript.setAttribute(attr.name, attr.value);
                });

                // Copy inline content if it exists
                if (oldScript.textContent) {
                newScript.textContent = oldScript.textContent;
                }

                // Replace the old <script> with the new one (this triggers execution)
                oldScript.parentNode.replaceChild(newScript, oldScript);
            } catch (err) {
                console.log("Error executing script:", err, oldScript);
            }
        });
    }
    
</script><script id="sidebar-data" type="application/json">
[
    "## Table of Contents",
    "## Connector Block",
    "### Features:",
    "### Example:",
    "### Syntax:",
    "### With Custom Attributes:",
    "## Grid System",
    "### Features:",
    "### Basic Grid:",
    "### Element 1",
    "### Element 2",
    "### Nested Element 1",
    "### Nested Element 2",
    "### Syntax:",
    "### Configuration Options:",
    "### Examples:",
    "## Float Elements",
    "### Creating a Float Element:",
    "### Triggering the Float Element:",
    "### Features:",
    "### Complete Example:",
    "## Callouts",
    "### Note Callout:",
    "### Warning Callout:",
    "### Features:",
    "## Details/Summary",
    "### Basic Details:",
    "### Open by Default:",
    "### Features:",
    "## Iframe Embedding",
    "### Syntax:",
    "### Features:",
    "### Example with Multiple Attributes:",
    "## Spacing Elements",
    "### Width Spacing:",
    "### Height Spacing:",
    "### Supported Units:",
    "### Examples:",
    "## Relative navigation link",
    "### Syntax:",
    "### Available Directions:",
    "### Stacking Directions:",
    "### Examples:",
    "## Additional Notes",
    "### Nesting Blocks:",
    "### Indentation:",
    "### Markdown Processing:",
    "## Tips and Best Practices",
    "## Quick Reference"
]
</script>