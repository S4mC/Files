<h1 id="12345">12345</h1><p>efwedwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqfwwqqdwq<br>Hola a todos jajajajajajjajajajjajjajjaja</p>
<p>Hola a tod sjajjajajajaja siuu+<br>dq<br>dq5d74w5qd<br>drewewewewewewew<br>eqqqqqqqqqqqqqqqq<br>f</p>
<p>console.log(&quot;Horlwqdwqrferefrferefaa a todos jajajajajja&quot;);</p>
<p>6565565</p>
<p>445465465465465465465465465465465465</p>
<script>
     console.log("Horlwefeqdwqrferefrferefaa a todos jaja84654654546ja565464ja");
    alert("liar");
</script><script id="entry-script">
(function setupCustomScrollLinks() {
    /* Make it scroll slowly with special functionalities */
    document.querySelectorAll("a").forEach((link) => {
        link.addEventListener("click", function (e) {
            const href = this.getAttribute("href") || this.getAttribute("xlink:href");

            // Only process if it's an internal link (starts with #)
            if (href && href.startsWith("#")) {
                e.preventDefault(); // prevents instant jump

                let target = null;
                const entryContent = document.querySelector(".entry-content");
                let targetId = href.substring(1); // substring removes the "#"

                targetId = decodeURIComponent(targetId);

                // Check if it's a special link with parameters
                if (targetId.includes("=")) {
                    // Use indexOf to properly handle values with spaces or special characters
                    const equalIndex = targetId.indexOf("=");
                    const type = targetId.substring(0, equalIndex);
                    const value = targetId.substring(equalIndex + 1);

                    if (type.match(/^h[1-6]$/)) {
                        // Search by position or by text in the specified h type
                        const headingLevel = parseInt(type.substring(1));

                        if (headingLevel >= 1 && headingLevel <= 6) {
                            const headings = entryContent
                                ? entryContent.querySelectorAll(`h${headingLevel}`)
                                : document.querySelectorAll(`h${headingLevel}`);

                            if (!isNaN(value)) {
                                // Search by position (e.g. #h2=3 searches for the third h2)
                                const elementIndex = parseInt(value) - 1; // Convert to 0-based index
                                if (elementIndex >= 0 && headings.length > elementIndex) {
                                    target = headings[elementIndex];
                                }
                            } else {
                                // Search by text (e.g. #h2=Introduction searches for the first h2 containing "Introduction")
                                const searchText = decodeURIComponent(value);
                                target = Array.from(headings).find((heading) =>
                                    heading.textContent.toLowerCase().includes(searchText.toLowerCase())
                                );
                            }
                        }
                    } else if (type === "text") {
                        const searchText = decodeURIComponent(value);
                        const searchArea = entryContent || document;

                        // Find all elements in order
                        const allElements = Array.from(searchArea.querySelectorAll("*"));

                        let firstMatch = null;
                        for (const element of allElements) {
                            if (element.textContent.includes(searchText)) {
                                firstMatch = element;
                                break; // we stop at the first one that contains the text
                            }
                        }

                        target = firstMatch;

                        // If we found something, we look for the deepest one inside it
                        if (firstMatch) {
                            // Recursive function to find the most nested element that contains the text
                            const findDeepestMatch = (el) => {
                                for (const child of el.children) {
                                    if (child.textContent.includes(searchText)) {
                                        // Search deeper in that child
                                        return findDeepestMatch(child);
                                    }
                                }
                                return el;
                            };

                            target = findDeepestMatch(firstMatch);
                        }
                    } else if (type === "query") {
                        // Execute custom querySelector (e.g. #query=document.querySelector("selector"))
                        try {
                            const queryString = decodeURIComponent(value);
                            // Evaluate the query safely
                            target = eval(queryString);
                        } catch (error) {
                            console.warn("Error executing query selector:", error);
                            target = null;
                        }
                    } else if (type === "goto") {
                        const queryString = decodeURIComponent(value);

                        // Helper function to check if element is visible
                        const isElementVisible = (element) => {
                            if (!element) return false;
                            const style = window.getComputedStyle(element);
                            const rect = element.getBoundingClientRect();
                            return (
                                style.display !== "none" &&
                                style.visibility !== "hidden" &&
                                style.opacity !== "0" &&
                                rect.width > 0 &&
                                rect.height > 0
                            );
                        };

                        // Helper function to find visible parent
                        const findVisibleParent = (element) => {
                            let parent = element.parentElement;
                            while (parent) {
                                if (isElementVisible(parent)) {
                                    return parent;
                                }
                                parent = parent.parentElement;
                            }

                            // If no visible parent found, check if parent node contains text nodes
                            // and wrap them if needed (for cases where element is inside text)
                            let parentNode = element.parentNode;
                            if (parentNode && parentNode.nodeType === Node.ELEMENT_NODE) {
                                // Check child nodes for text content
                                for (let node of parentNode.childNodes) {
                                    if (
                                        node !== element &&
                                        node.nodeType === Node.TEXT_NODE &&
                                        node.textContent.trim()
                                    ) {
                                        // Found text node sibling, wrap parent's content
                                        const wrapper = document.createElement("div");
                                        wrapper.style.display = "inline-block";

                                        // Move all child nodes to wrapper
                                        while (parentNode.firstChild) {
                                            wrapper.appendChild(parentNode.firstChild);
                                        }

                                        parentNode.appendChild(wrapper);
                                        return wrapper;
                                    }
                                }
                            }

                            return null;
                        };

                        // Helper function to find visible previous sibling
                        const findVisiblePreviousSibling = (element) => {
                            // Start directly with previousSibling to catch both elements and text nodes
                            let prevNode = element.previousSibling;
                            while (prevNode) {
                                // Check if it's a text node with actual content (not just whitespace)
                                if (
                                    prevNode.nodeType === Node.TEXT_NODE &&
                                    prevNode.textContent.trim()
                                ) {
                                    // Wrap the text node in a span element
                                    const wrapper = document.createElement("span");
                                    wrapper.textContent = prevNode.textContent;
                                    prevNode.parentNode.replaceChild(wrapper, prevNode);
                                    return wrapper;
                                }
                                // If it's an element, check if it's visible
                                if (
                                    prevNode.nodeType === Node.ELEMENT_NODE &&
                                    isElementVisible(prevNode)
                                ) {
                                    return prevNode;
                                }
                                prevNode = prevNode.previousSibling;
                            }

                            return null;
                        };

                        // Helper function to find visible next sibling
                        const findVisibleNextSibling = (element) => {
                            // Start directly with nextSibling to catch both elements and text nodes
                            let nextNode = element.nextSibling;

                            while (nextNode) {
                                // Check if it's a text node with actual content (not just whitespace)
                                if (
                                    nextNode.nodeType === Node.TEXT_NODE &&
                                    nextNode.textContent.trim()
                                ) {
                                    // Wrap the text node in a span element
                                    const wrapper = document.createElement("span");
                                    wrapper.textContent = nextNode.textContent;
                                    nextNode.parentNode.replaceChild(wrapper, nextNode);
                                    return wrapper;
                                }
                                // If it's an element, check if it's visible
                                if (
                                    nextNode.nodeType === Node.ELEMENT_NODE &&
                                    isElementVisible(nextNode)
                                ) {
                                    return nextNode;
                                }
                                nextNode = nextNode.nextSibling;
                            }

                            return null;
                        };

                        // Helper function to find first visible child (enter element)
                        const findVisibleFirstChild = (element) => {
                            // Start with first child to catch both elements and text nodes
                            let firstNode = element.firstChild;

                            while (firstNode) {
                                // Check if it's a text node with actual content (not just whitespace)
                                if (
                                    firstNode.nodeType === Node.TEXT_NODE &&
                                    firstNode.textContent.trim()
                                ) {
                                    // Wrap the text node in a span element
                                    const wrapper = document.createElement("span");
                                    wrapper.textContent = firstNode.textContent;
                                    firstNode.parentNode.replaceChild(wrapper, firstNode);
                                    return wrapper;
                                }
                                // If it's an element, check if it's visible
                                if (
                                    firstNode.nodeType === Node.ELEMENT_NODE &&
                                    isElementVisible(firstNode)
                                ) {
                                    return firstNode;
                                }
                                firstNode = firstNode.nextSibling;
                            }

                            return null;
                        };

                        // Helper function to find last visible child (enter element at end)
                        const findVisibleLastChild = (element) => {
                            // Start with last child to catch both elements and text nodes
                            let lastNode = element.lastChild;

                            while (lastNode) {
                                // Check if it's a text node with actual content (not just whitespace)
                                if (
                                    lastNode.nodeType === Node.TEXT_NODE &&
                                    lastNode.textContent.trim()
                                ) {
                                    // Wrap the text node in a span element
                                    const wrapper = document.createElement("span");
                                    wrapper.textContent = lastNode.textContent;
                                    lastNode.parentNode.replaceChild(wrapper, lastNode);
                                    return wrapper;
                                }
                                // If it's an element, check if it's visible
                                if (
                                    lastNode.nodeType === Node.ELEMENT_NODE &&
                                    isElementVisible(lastNode)
                                ) {
                                    return lastNode;
                                }
                                lastNode = lastNode.previousSibling;
                            }

                            return null;
                        };

                        // Helper function to apply a single navigation direction
                        const applyDirection = (currentElement, direction) => {
                            switch (direction) {
                                case "out":
                                    return findVisibleParent(currentElement);
                                case "above":
                                    return findVisiblePreviousSibling(currentElement);
                                case "below":
                                    return findVisibleNextSibling(currentElement);
                                case "in":
                                    return findVisibleFirstChild(currentElement);
                                case "inl":
                                    return findVisibleLastChild(currentElement);
                                default:
                                    console.warn("Unknown direction:", direction);
                                    return null;
                            }
                        };

                        // Search for all go-navigate elements (new unified class)
                        const goNavigateElements = document.querySelectorAll(".go-navigate");
                        for (const element of goNavigateElements) {
                            if (element.getAttribute("data-name") === queryString) {
                                const directionsStr = element.getAttribute("data-directions");
                                const directions = directionsStr.split("-"); // Split "out-out-below" into ["out", "out", "below"]

                                // Apply each direction in sequence
                                let currentTarget = element;
                                for (const direction of directions) {
                                    currentTarget = applyDirection(currentTarget, direction);
                                    if (!currentTarget) {
                                        console.warn("Navigation failed at direction:", direction);
                                        break;
                                    }
                                }

                                if (currentTarget) {
                                    target = currentTarget;
                                    break;
                                }
                            }
                        }

                        if (!target) {
                            console.warn("No visible target found for goto:", queryString);
                        }
                    }
                } else {
                    // Normal search by ID
                    target = document.getElementById(targetId);
                }

                if (target) {
                    // Detect which element handles the scroll
                    const entryContent = document.getElementsByClassName("entry-content")[0];
                    let container = null;
                    let isBodyScroll = false;

                    // Check if entry-content exists and has scrolling
                    if (entryContent) {
                        const hasScroll = entryContent.scrollHeight > entryContent.clientHeight;
                        const hasOverflow =
                            window.getComputedStyle(entryContent).overflowY !== "visible";

                        if (hasScroll && hasOverflow) {
                            container = entryContent;
                        }
                    }

                    // If no scrollable container found, use body/document
                    if (!container) {
                        container = document.scrollingElement || document.documentElement;
                        isBodyScroll = true;
                    }

                    // Calculate scroll position
                    if (container) {
                        const targetRect = target.getBoundingClientRect();

                        let scrollTop;
                        if (isBodyScroll) {
                            // For body scroll: calculate from top of page
                            const targetTop = targetRect.top + window.scrollY;
                            const viewportHeight = window.innerHeight;
                            scrollTop = targetTop - viewportHeight / 2 + targetRect.height / 2;
                        } else {
                            // For container scroll: calculate relative to container
                            const containerRect = container.getBoundingClientRect();
                            const relativeTop = targetRect.top - containerRect.top + container.scrollTop;
                            scrollTop = relativeTop - container.clientHeight / 2 + targetRect.height / 2;
                        }

                        // Perform scroll
                        container.scrollTo({
                            top: Math.max(0, scrollTop),
                            behavior: "smooth",
                        });
                    }

                    // Wait for scroll to finish and element to be visible
                    const applyHighlight = () => {
                        if (window.highlightTargetTimeoutOut)
                            clearTimeout(window.highlightTargetTimeoutOut);

                        // Clear previous animations from all elements
                        document.querySelectorAll('[style*="animation"]').forEach((el) => {
                            if (el.style.animation.includes("targetZoom")) {
                                el.style.animation = "";
                            }
                        });

                        // Force reflow to ensure animation restarts
                        void target.offsetWidth;

                        // Add highlighting animation
                        target.style.animation = "targetZoom 1.5s ease-out";

                        // Remove animation after completion
                        window.highlightTargetTimeoutOut = setTimeout(() => {
                            target.style.animation = "";
                        }, 1500);
                    };

                    // Detect when scroll ends
                    let observer;
                    let observerTimeout;

                    const onScrollEnd = (event) => {
                        if (observerTimeout) clearTimeout(observerTimeout);
                        observer?.disconnect();

                        // Check if element is visible in viewport
                        const targetRect = target.getBoundingClientRect();
                        let containerRect;

                        if (isBodyScroll) {
                            containerRect = { top: 0, bottom: window.innerHeight };
                        } else {
                            containerRect = container.getBoundingClientRect();
                        }

                        const isVisible =
                            targetRect.top < containerRect.bottom &&
                            targetRect.bottom > containerRect.top;

                        if (isVisible) {
                            // Element is visible, apply highlight
                            if (event) {
                                if (isBodyScroll) {
                                    window.removeEventListener(event, onScrollEnd);
                                } else {
                                    container.removeEventListener(event, onScrollEnd);
                                }
                            }
                            applyHighlight();
                        } else {
                            // Element is not visible yet, use IntersectionObserver
                            if (event) {
                                if (isBodyScroll) {
                                    window.removeEventListener(event, onScrollEnd);
                                } else {
                                    container.removeEventListener(event, onScrollEnd);
                                }
                            }

                            observer = new IntersectionObserver(
                                (entries) => {
                                    entries.forEach((entry) => {
                                        if (entry.isIntersecting) {
                                            observer.disconnect();
                                            applyHighlight();
                                        }
                                    });
                                },
                                {
                                    root: isBodyScroll ? null : container,
                                    threshold: 0.1,
                                }
                            );

                            observer.observe(target);

                            // Cleanup observer after 5 seconds if element never becomes visible
                            observerTimeout = setTimeout(() => {
                                observer?.disconnect();
                            }, 5000);
                        }
                    };

                    if (container) {
                        const scrollTarget = isBodyScroll ? window : container;
                        if ("onscrollend" in document.documentElement) {
                            scrollTarget.addEventListener("scrollend", onScrollEnd("scrollend"));
                        } else {
                            scrollTarget.addEventListener("scroll", onScrollEnd("scroll"));
                        }
                        // Trigger once immediately in case scroll doesn't happen
                        onScrollEnd();
                    }
                }
            }
        });
    });
})();(function setupDetailsAnimation() {
    // Remover listener anterior del documento si existe
    if (window.detailsClickHandler) {
        document.removeEventListener("click", window.detailsClickHandler);
    }

    // Crear el handler
    window.detailsClickHandler = function (e) {
        const details = e.target.closest("details");
        if (!details) return;

        const summary = e.target.closest("summary");
        if (!summary) return;

        const contentWrapper = details.querySelector(".content-wrapper-details");
        if (!contentWrapper) return;

        e.preventDefault();

        if (details.open) {
            // Close with animation
            contentWrapper.classList.add("animating");
            contentWrapper.classList.remove("opening");

            setTimeout(() => {
                details.open = false;
                contentWrapper.classList.remove("animating");
            }, 400);
        } else {
            // Open with animation
            details.open = true;
            contentWrapper.classList.add("animating");

            // Forzar reflow
            contentWrapper.offsetHeight;

            contentWrapper.classList.add("opening");

            setTimeout(() => {
                contentWrapper.classList.remove("animating");
            }, 400);
        }
    };

    // Agregar un solo listener al documento
    document.addEventListener("click", window.detailsClickHandler);

    // Inicializar estado de contenido ya abierto
    document.querySelectorAll("details[open]").forEach((details) => {
        const contentWrapper = details.querySelector(".content-wrapper-details");
        contentWrapper.classList.add("opening");
    });
})();(function setupFloatingElements() {
    // Clean previous event listeners if they exist
    if (window.floatEventListeners) {
        if (window.floatEventListeners.triggerClick) {
            window.floatEventListeners.triggerClick.forEach((item) => {
                item.element.removeEventListener("click", item.handler);
            });
        }
        if (window.floatEventListeners.documentClick) {
            document.removeEventListener("click", window.floatEventListeners.documentClick);
        }
        if (window.floatEventListeners.documentKeydown) {
            document.removeEventListener("keydown", window.floatEventListeners.documentKeydown);
        }
    }

    // Inicializar el objeto para almacenar los event listeners
    window.floatEventListeners = {
        triggerClick: [],
        documentClick: null,
        documentKeydown: null,
        activeFloats: new Set(),
    };

    // Manejar los elementos flotantes
    document.querySelectorAll(".float-trigger").forEach((trigger) => {
        const clickHandler = function () {
            const floatId = this.getAttribute("data-float-id");
            const floatContainer = document.getElementById("float-" + floatId);

            if (!floatContainer) return;

            // If the container is already visible, we close it
            if (floatContainer.classList.contains("visible")) {
                floatContainer.classList.remove("visible");
                window.floatEventListeners.activeFloats.delete(floatId);
                return;
            }

            // Close all floating containers that are open
            document.querySelectorAll(".float-container.visible").forEach((container) => {
                container.classList.remove("visible");
                const openFloatId = container.id.replace("float-", "");
                window.floatEventListeners.activeFloats.delete(openFloatId);
            });

            // Mostrar el contenedor
            floatContainer.classList.add("visible");
            void floatContainer.offsetWidth; // reflow force before measuring
            window.floatEventListeners.activeFloats.add(floatId);

            const triggerRect = this.getBoundingClientRect();
            const parentRect = floatContainer.offsetParent.getBoundingClientRect();

            // Find the scrollable container (entry-content or closest scrollable parent)
            let scrollContainer = this.closest(".entry-content");
            if (!scrollContainer) {
                scrollContainer = this.closest('[style*="overflow"]') || document.documentElement;
            }

            // Get scroll offsets
            const scrollLeft = scrollContainer.scrollLeft || 0;
            const scrollTop = scrollContainer.scrollTop || 0;

            let left = triggerRect.left - parentRect.left + scrollLeft;
            let top = triggerRect.bottom - parentRect.top + scrollTop + 10;

            const floatWidth = floatContainer.offsetWidth;
            const floatHeight = floatContainer.offsetHeight;
            const parentWidth = floatContainer.offsetParent.clientWidth;
            const parentHeight = floatContainer.offsetParent.clientHeight;

            // Ajustar horizontal
            if (left + floatWidth > parentWidth - 10) {
                left = parentWidth - floatWidth - 10;
            }
            if (left < 0) {
                left = 0;
            }

            // Ajustar vertical - considerar tanto el viewport del contenedor con scroll como el viewport de la ventana
            const scrollContainerRect = scrollContainer.getBoundingClientRect();
            const triggerBottomRelativeToScroll = triggerRect.bottom - scrollContainerRect.top;
            const availableSpaceInContainer =
                scrollContainer.clientHeight - triggerBottomRelativeToScroll;

            // También verificar si se sale del viewport de la ventana
            const availableSpaceInWindow = window.innerHeight - triggerRect.bottom;

            // Si el contenedor tiene scroll, usar su espacio disponible, sino usar el de la ventana
            const hasContainerScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;
            const shouldCheckContainer =
                hasContainerScroll && scrollContainer !== document.documentElement;

            let shouldPlaceAbove = false;
            if (shouldCheckContainer) {
                // El contenedor tiene scroll, verificar espacio en el contenedor
                shouldPlaceAbove = availableSpaceInContainer < floatHeight + 50;
            } else {
                // El contenedor no tiene scroll, verificar espacio en la ventana
                shouldPlaceAbove = availableSpaceInWindow < floatHeight + 50;
            }

            if (shouldPlaceAbove) {
                // si no cabe debajo, colócalo arriba del trigger
                top = triggerRect.top - parentRect.top + scrollTop - floatHeight - 10;
            }

            // Asegurar que no se salga por arriba
            const minTop = shouldCheckContainer ? scrollTop + 10 : 10;
            if (top < minTop) {
                top = minTop;
            }

            // Asegurar que no se salga por abajo del viewport de la ventana
            if (!shouldCheckContainer) {
                const maxTop = window.innerHeight - floatHeight - 20;
                const currentTopInViewport = top - scrollTop + parentRect.top;
                if (currentTopInViewport > maxTop) {
                    top = maxTop + scrollTop - parentRect.top;
                }
            }

            floatContainer.style.left = left + "px";
            floatContainer.style.top = top + "px";
        };

        trigger.addEventListener("click", clickHandler);
        window.floatEventListeners.triggerClick.push({
            element: trigger,
            handler: clickHandler,
        });
    });

    // Cerrar los elementos flotantes al hacer clic fuera
    const documentClickHandler = function (e) {
        if (e.target.classList.contains("float-close")) {
            const container = e.target.closest(".float-container");
            if (container) {
                container.classList.remove("visible");
                const floatId = container.id.replace("float-", "");
                window.floatEventListeners.activeFloats.delete(floatId);
            }
        } else if (!e.target.closest(".float-container") && !e.target.closest(".float-trigger")) {
            document.querySelectorAll(".float-container.visible").forEach((container) => {
                container.classList.remove("visible");
                const floatId = container.id.replace("float-", "");
                window.floatEventListeners.activeFloats.delete(floatId);
            });
        }
    };

    document.addEventListener("click", documentClickHandler);
    window.floatEventListeners.documentClick = documentClickHandler;

    // Cerrar con ESC
    const documentKeydownHandler = function (e) {
        if (e.key === "Escape") {
            document.querySelectorAll(".float-container.visible").forEach((container) => {
                container.classList.remove("visible");
                const floatId = container.id.replace("float-", "");
                window.floatEventListeners.activeFloats.delete(floatId);
            });
        }
    };

    document.addEventListener("keydown", documentKeydownHandler);
    window.floatEventListeners.documentKeydown = documentKeydownHandler;

    // Global method to close all floating elements
    window.closeAllFloats = function () {
        document.querySelectorAll(".float-container.visible").forEach((container) => {
            container.classList.remove("visible");
        });
        window.floatEventListeners.activeFloats.clear();
    };
})();(function executeEntryContentScripts() {
    // Select the first element with class "entry-content"
    const entryContent = document.querySelector(".entry-content");

    if (entryContent) {
        // Select all <script> elements within that element
        const scripts = entryContent.querySelectorAll("script");

        scripts.forEach((oldScript) => {
            try {
                // Create a new script element to execute
                const newScript = document.createElement("script");

                // Copy attributes (e.g., src, type, etc.)
                Array.from(oldScript.attributes).forEach((attr) => {
                    newScript.setAttribute(attr.name, attr.value);
                });

                // Copy inline content if it exists
                if (oldScript.textContent) {
                    newScript.textContent = oldScript.textContent;
                }

                // Replace the old <script> with the new one (this triggers execution)
                oldScript.parentNode.replaceChild(newScript, oldScript);
            } catch (err) {
                console.log("Error executing script:", err, oldScript);
            }
        });
    }
})();
</script><script id="sidebar-data" type="application/json">
[]
</script>