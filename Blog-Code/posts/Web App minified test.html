<h1 id="web-app">Web App</h1><p>Create a Preact Web App with Vite and htm<br></p>
<h2 id="section-0">Tools</h2><ul>
<li><p>Vite:<br>  It helps to compile the code, minify it, put together the node modules.<br>  run:<br>   bash <code class="language-">npm create vite@latest my-preact-htm-site -- --template vanilla</code></p>
</li>
<li><p>Preact:<br>  Helps keep code in components.<br>  run:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre class=""><code class="language-bash">npm init -y
npm install preact</code></pre></div></p>
</li>
<li><p>Htm:<br>  Helps write the HTML of the components without using JSX, using template strings<br>  run:<br>   bash <code class="language-">npm install preact htm</code></p>
</li>
</ul>
<br>

<h2 id="section-1">Configuration</h2><ol start="1">
<li><p>Install the tools, in Vite create a vanilla JS proyect</p>
</li>
<li><p>Create <code class="language-green">vite.config.js</code> in the root folder for compile all html and put relative paths<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><button class="code-folding-button" title="Fold/Unfold Code">
                <svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m6 9l6 6l6-6"/></svg>
            </button><pre class=" folded"><code class="language-javascript">import { defineConfig } from &quot;vite&quot;;
import { resolve } from &quot;path&quot;;
import { readdirSync } from &quot;fs&quot;;

// Automatically find all HTML files in the root directory
const htmlFiles = readdirSync(&quot;.&quot;).filter((file) =&gt; file.endsWith(&quot;.html&quot;));
const input = Object.fromEntries(
    htmlFiles.map((file) =&gt; [
        file.replace(&quot;.html&quot;, &quot;&quot;), // Use filename without extension as the key
        resolve(__dirname, file),
    ])
);

export default defineConfig({
    base: &quot;./&quot;, // Use relative paths in build output
    build: {
        rollupOptions: {
            input,
        },
    },
});</code></pre></div></p>
</li>
<li><p>Create <code class="language-green">commands.md</code> in the root folder for save and run the commands:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre class=""><code class="language-markdown">Commands in the proyect:
run `npx vite`(Run preview)
run `npx vite build`(Build)</code></pre></div></p>
</li>
<li><p>Create <code class="language-green">util.js</code> in the <code class="language-purple">components</code> folder for easy access to tools:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><button class="code-folding-button" title="Fold/Unfold Code">
                <svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m6 9l6 6l6-6"/></svg>
            </button><pre class=" folded"><code class="language-javascript">// utils.js - Common utilities for Preact with HTM
import { h } from &#039;preact&#039;;
import htm from &#039;htm&#039;;
import { useState, useEffect, useRef } from &#039;preact/hooks&#039;;
import { render } from &#039;preact&#039;;

// html - To use JSX syntax with htm
const html = htm.bind(h);

// querySelector
const $ = (selector) =&gt; document.querySelector(selector);

export default html;
export { html, $, useState, useEffect, useRef, render };</code></pre></div></p>
</li>
<li><p>Create or edit <code class="language-green">style.css</code> in the <code class="language-purple">styles</code> folder for a global style and themes:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><button class="code-folding-button" title="Fold/Unfold Code">
                <svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m6 9l6 6l6-6"/></svg>
            </button><pre class=" folded"><code class="language-javascript">:root {
    /* Common variables for all themes */
    --border-radius: 8px;
    --spacing-xs: 4px;
    --spacing-sm: 8px;
    --spacing-md: 16px;
    --spacing-lg: 24px;
    --spacing-xl: 32px;
    --spacing-2xl: 48px;

    /* Font */
    --font-family: &quot;Ubuntu&quot;, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Cantarell,
        &quot;Helvetica Neue&quot;, sans-serif;
}

/* Themes */
:root,
[data-theme=&quot;dark&quot;] {
    /* Dark theme style */
    --chroma: 0.01; /* 0.0 to 0.2 */
    --hue: 126; /* 20 to 340 */

    --primary-color: #a5c14f;
    --accent-color: #238636;
    --error-color: #ef4444;

    --bg: oklch(0.15 var(--chroma) var(--hue));
    --bg-dark: oklch(0.1 var(--chroma) var(--hue));
    --bg-light: oklch(0.2 var(--chroma) var(--hue));
    --bg-highlight: oklch(0.25 var(--chroma) var(--hue));
    --bg-hover: oklch(0.5 0.03 246);

    --color: oklch(0.96 0.03 246);
    --color-secondary: oklch(0.76 0.03 246);
    --color-muted: #a1a1aa;

    --border: oklch(0.4 0.03 246);
    --border-muted: oklch(0.3 0.03 246);

    --scroll-bar: var(--color-muted) var(--bg-highlight);
}

[data-theme=&quot;dark-green&quot;] {
    /* Dark Green theme style */
    --chroma: 0.015; /* 0.0 to 0.2 */
    --hue: 150; /* 20 to 340 */
}

[data-theme=&quot;dark-blue&quot;] {
    /* Dark Blue theme style */
    --chroma: 0.015; /* 0.0 to 0.2 */
    --hue: 246; /* 20 to 340 */
}

[data-theme=&quot;light&quot;] {
    /* Light theme by default */
    --chroma: 0; /* 0.0 to 0.2 */
    --hue: 110; /* 20 to 340 */

    --primary-color: oklch(0.4 0.1 126);
    --accent-color: #f59e0b;
    --error-color: #ef4444;

    --bg: oklch(0.98 var(--chroma) var(--hue));
    --bg-dark: oklch(1 var(--chroma) var(--hue));
    --bg-light: oklch(0.96 var(--chroma) var(--hue));
    --bg-highlight: oklch(0.9 var(--chroma) var(--hue));
    --bg-hover: oklch(0.86 0.01 var(--hue));

    --color: oklch(0.1 0.02 var(--hue));
    --color-secondary: oklch(0.2 0.02 var(--hue));
    --color-muted: #94a3b8;

    --border: oklch(0.7 0.01 var(--hue));
    --border-muted: oklch(0.8 0.01 var(--hue));

    --scroll-bar: var(--color-muted) var(--bg-highlight);
}

/* Global styles */
* {
    margin: 0;
    padding: 0;
    outline: none;
    box-sizing: border-box;
}

html {
    scrollbar-width: thin;
    scrollbar-color: var(--scroll-bar);
}

body {
    font-family: var(--font-family);
    line-height: 1.6;
    color: var(--color-secondary);
    background-color: var(--bg-dark);
}</code></pre></div></p>
</li>
<li><p>Modify the <code class="language-green">index.html</code> and put:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><button class="code-folding-button" title="Fold/Unfold Code">
                <svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m6 9l6 6l6-6"/></svg>
            </button><pre class=" folded"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/icon.svg&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
        &lt;!-- You can also import the js code from another file --&gt;
        &lt;!-- &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt; --&gt;
        &lt;script type=&quot;module&quot;&gt;
            import &quot;./styles/style.css&quot;;
            import { html, $, render } from &quot;./components/utils.js&quot;;
            import Counter from &#039;./components/counter.js&#039;;
            function App() {
                return html`
                    &lt;h1&gt;Hello world&lt;/h1&gt;
                    &lt;${Counter} /&gt;
                `;
            }
            render(html`&lt;${App} /&gt;`, $(&quot;#app&quot;));
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre></div> The <code class="language-green">counter.js</code> component used is:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><button class="code-folding-button" title="Fold/Unfold Code">
                <svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m6 9l6 6l6-6"/></svg>
            </button><pre class=" folded"><code class="language-js">import {html, useState } from &#039;./utils.js&#039;;

export default function Counter() {
const [count, setCount] = useState(0);
return html`
    &lt;div class=&quot;counter&quot;&gt;
    &lt;p&gt;Contador: ${count}&lt;/p&gt;
    &lt;button onClick=${() =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
`;
}</code></pre></div></p>
</li>
<li><p>If you are going to use github create <code class="language-green">.gitignore</code> in the root folder and put:<div class="code-block-wrapper min"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><button class="code-folding-button" title="Fold/Unfold Code">
                <svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m6 9l6 6l6-6"/></svg>
            </button><pre class=" folded"><code class="language-markdown"># Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
docs
dist-ssr
*.local

# Editor directories and files
.vscode/*
.github/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?</code></pre></div></p>
</li>
<li><p>If you are going to use copilot create <code class="language-green">copilot-instructions.md</code> in the <code class="language-purple">.github</code> folder, you can put things like:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre class=""><code class="language-markdown">Always write comments in English.
Ignore the /dist folder.</code></pre></div></p>
</li>
</ol>
<h2 id="section-2">How to set a language selector</h2><p>Run:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre class=""><code class="language-bash">npm install i18next</code></pre></div></p>
<p>In <code class="language-javascript">defineConfig({</code> in <code class="language-green">vite.config.js</code> add:<div class="code-block-wrapper"><button class="code-copy-button">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M13 13H7a2 2 0 01-2-2V5a2 2 0 012-2h6a2 2 0 012 2v6a2 2 0 01-2 2z" stroke="currentColor" stroke-width="2"/>
                    <path d="M3 11V3a2 2 0 012-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button><pre class=""><code class="language-bash">define: {
    __BUILD_NUMBER__: JSON.stringify(Date.now()),
},</code></pre></div></p>
<p><br><br><br></p>
<p>COMO PONER UN SELECTOR DE TEMA</p>
<script id="entry-script">
(function setupCustomScrollLinks() {
    /* Make it scroll slowly with special functionalities */
    document.querySelectorAll("a").forEach((link) => {
        link.addEventListener("click", function (e) {
            const href = this.getAttribute("href") || this.getAttribute("xlink:href");

            // Only process if it's an internal link (starts with #)
            if (href && href.startsWith("#")) {
                e.preventDefault(); // prevents instant jump

                let target = null;
                const entryContent = document.querySelector(".entry-content");
                let targetId = href.substring(1); // substring removes the "#"

                targetId = decodeURIComponent(targetId);

                // Check if it's a special link with parameters
                if (targetId.includes("=")) {
                    // Use indexOf to properly handle values with spaces or special characters
                    const equalIndex = targetId.indexOf("=");
                    const type = targetId.substring(0, equalIndex);
                    const value = targetId.substring(equalIndex + 1);

                    if (type.match(/^h[1-6]$/)) {
                        // Search by position or by text in the specified h type
                        const headingLevel = parseInt(type.substring(1));

                        if (headingLevel >= 1 && headingLevel <= 6) {
                            const headings = entryContent
                                ? entryContent.querySelectorAll(`h${headingLevel}`)
                                : document.querySelectorAll(`h${headingLevel}`);

                            if (!isNaN(value)) {
                                // Search by position (e.g. #h2=3 searches for the third h2)
                                const elementIndex = parseInt(value) - 1; // Convert to 0-based index
                                if (elementIndex >= 0 && headings.length > elementIndex) {
                                    target = headings[elementIndex];
                                }
                            } else {
                                // Search by text (e.g. #h2=Introduction searches for the first h2 containing "Introduction")
                                const searchText = decodeURIComponent(value);
                                target = Array.from(headings).find((heading) =>
                                    heading.textContent.toLowerCase().includes(searchText.toLowerCase())
                                );
                            }
                        }
                    } else if (type === "text") {
                        const searchText = decodeURIComponent(value);
                        const searchArea = entryContent || document;

                        // Find all elements in order
                        const allElements = Array.from(searchArea.querySelectorAll("*"));

                        let firstMatch = null;
                        for (const element of allElements) {
                            if (element.textContent.includes(searchText)) {
                                firstMatch = element;
                                break; // we stop at the first one that contains the text
                            }
                        }

                        target = firstMatch;

                        // If we found something, we look for the deepest one inside it
                        if (firstMatch) {
                            // Recursive function to find the most nested element that contains the text
                            const findDeepestMatch = (el) => {
                                for (const child of el.children) {
                                    if (child.textContent.includes(searchText)) {
                                        // Search deeper in that child
                                        return findDeepestMatch(child);
                                    }
                                }
                                return el;
                            };

                            target = findDeepestMatch(firstMatch);
                        }
                    } else if (type === "query") {
                        // Execute custom querySelector (e.g. #query=document.querySelector("selector"))
                        try {
                            const queryString = decodeURIComponent(value);
                            // Evaluate the query safely
                            target = eval(queryString);
                        } catch (error) {
                            console.warn("Error executing query selector:", error);
                            target = null;
                        }
                    } else if (type === "goto") {
                        const queryString = decodeURIComponent(value);

                        // Helper function to check if element is visible
                        const isElementVisible = (element) => {
                            if (!element) return false;
                            const style = window.getComputedStyle(element);
                            const rect = element.getBoundingClientRect();
                            return (
                                style.display !== "none" &&
                                style.visibility !== "hidden" &&
                                style.opacity !== "0" &&
                                rect.width > 0 &&
                                rect.height > 0
                            );
                        };

                        // Helper function to find visible parent
                        const findVisibleParent = (element) => {
                            let parent = element.parentElement;
                            while (parent) {
                                if (isElementVisible(parent)) {
                                    return parent;
                                }
                                parent = parent.parentElement;
                            }

                            // If no visible parent found, check if parent node contains text nodes
                            // and wrap them if needed (for cases where element is inside text)
                            let parentNode = element.parentNode;
                            if (parentNode && parentNode.nodeType === Node.ELEMENT_NODE) {
                                // Check child nodes for text content
                                for (let node of parentNode.childNodes) {
                                    if (
                                        node !== element &&
                                        node.nodeType === Node.TEXT_NODE &&
                                        node.textContent.trim()
                                    ) {
                                        // Found text node sibling, wrap parent's content
                                        const wrapper = document.createElement("div");
                                        wrapper.style.display = "inline-block";

                                        // Move all child nodes to wrapper
                                        while (parentNode.firstChild) {
                                            wrapper.appendChild(parentNode.firstChild);
                                        }

                                        parentNode.appendChild(wrapper);
                                        return wrapper;
                                    }
                                }
                            }

                            return null;
                        };

                        // Helper function to find visible previous sibling
                        const findVisiblePreviousSibling = (element) => {
                            // Start directly with previousSibling to catch both elements and text nodes
                            let prevNode = element.previousSibling;
                            while (prevNode) {
                                // Check if it's a text node with actual content (not just whitespace)
                                if (
                                    prevNode.nodeType === Node.TEXT_NODE &&
                                    prevNode.textContent.trim()
                                ) {
                                    // Wrap the text node in a span element
                                    const wrapper = document.createElement("span");
                                    wrapper.textContent = prevNode.textContent;
                                    prevNode.parentNode.replaceChild(wrapper, prevNode);
                                    return wrapper;
                                }
                                // If it's an element, check if it's visible
                                if (
                                    prevNode.nodeType === Node.ELEMENT_NODE &&
                                    isElementVisible(prevNode)
                                ) {
                                    return prevNode;
                                }
                                prevNode = prevNode.previousSibling;
                            }

                            return null;
                        };

                        // Helper function to find visible next sibling
                        const findVisibleNextSibling = (element) => {
                            // Start directly with nextSibling to catch both elements and text nodes
                            let nextNode = element.nextSibling;

                            while (nextNode) {
                                // Check if it's a text node with actual content (not just whitespace)
                                if (
                                    nextNode.nodeType === Node.TEXT_NODE &&
                                    nextNode.textContent.trim()
                                ) {
                                    // Wrap the text node in a span element
                                    const wrapper = document.createElement("span");
                                    wrapper.textContent = nextNode.textContent;
                                    nextNode.parentNode.replaceChild(wrapper, nextNode);
                                    return wrapper;
                                }
                                // If it's an element, check if it's visible
                                if (
                                    nextNode.nodeType === Node.ELEMENT_NODE &&
                                    isElementVisible(nextNode)
                                ) {
                                    return nextNode;
                                }
                                nextNode = nextNode.nextSibling;
                            }

                            return null;
                        };

                        // Helper function to find first visible child (enter element)
                        const findVisibleFirstChild = (element) => {
                            // Start with first child to catch both elements and text nodes
                            let firstNode = element.firstChild;

                            while (firstNode) {
                                // Check if it's a text node with actual content (not just whitespace)
                                if (
                                    firstNode.nodeType === Node.TEXT_NODE &&
                                    firstNode.textContent.trim()
                                ) {
                                    // Wrap the text node in a span element
                                    const wrapper = document.createElement("span");
                                    wrapper.textContent = firstNode.textContent;
                                    firstNode.parentNode.replaceChild(wrapper, firstNode);
                                    return wrapper;
                                }
                                // If it's an element, check if it's visible
                                if (
                                    firstNode.nodeType === Node.ELEMENT_NODE &&
                                    isElementVisible(firstNode)
                                ) {
                                    return firstNode;
                                }
                                firstNode = firstNode.nextSibling;
                            }

                            return null;
                        };

                        // Helper function to find last visible child (enter element at end)
                        const findVisibleLastChild = (element) => {
                            // Start with last child to catch both elements and text nodes
                            let lastNode = element.lastChild;

                            while (lastNode) {
                                // Check if it's a text node with actual content (not just whitespace)
                                if (
                                    lastNode.nodeType === Node.TEXT_NODE &&
                                    lastNode.textContent.trim()
                                ) {
                                    // Wrap the text node in a span element
                                    const wrapper = document.createElement("span");
                                    wrapper.textContent = lastNode.textContent;
                                    lastNode.parentNode.replaceChild(wrapper, lastNode);
                                    return wrapper;
                                }
                                // If it's an element, check if it's visible
                                if (
                                    lastNode.nodeType === Node.ELEMENT_NODE &&
                                    isElementVisible(lastNode)
                                ) {
                                    return lastNode;
                                }
                                lastNode = lastNode.previousSibling;
                            }

                            return null;
                        };

                        // Helper function to apply a single navigation direction
                        const applyDirection = (currentElement, direction) => {
                            switch (direction) {
                                case "out":
                                    return findVisibleParent(currentElement);
                                case "above":
                                    return findVisiblePreviousSibling(currentElement);
                                case "below":
                                    return findVisibleNextSibling(currentElement);
                                case "in":
                                    return findVisibleFirstChild(currentElement);
                                case "inl":
                                    return findVisibleLastChild(currentElement);
                                default:
                                    console.warn("Unknown direction:", direction);
                                    return null;
                            }
                        };

                        // Search for all go-navigate elements (new unified class)
                        const goNavigateElements = document.querySelectorAll(".go-navigate");
                        for (const element of goNavigateElements) {
                            if (element.getAttribute("data-name") === queryString) {
                                const directionsStr = element.getAttribute("data-directions");
                                const directions = directionsStr.split("-"); // Split "out-out-below" into ["out", "out", "below"]

                                // Apply each direction in sequence
                                let currentTarget = element;
                                for (const direction of directions) {
                                    currentTarget = applyDirection(currentTarget, direction);
                                    if (!currentTarget) {
                                        console.warn("Navigation failed at direction:", direction);
                                        break;
                                    }
                                }

                                if (currentTarget) {
                                    target = currentTarget;
                                    break;
                                }
                            }
                        }

                        if (!target) {
                            console.warn("No visible target found for goto:", queryString);
                        }
                    }
                } else {
                    // Normal search by ID
                    target = document.getElementById(targetId);
                }

                if (target) {
                    // Detect which element handles the scroll
                    const entryContent = document.getElementsByClassName("entry-content")[0];
                    let container = null;
                    let isBodyScroll = false;

                    // Check if entry-content exists and has scrolling
                    if (entryContent) {
                        const hasScroll = entryContent.scrollHeight > entryContent.clientHeight;
                        const hasOverflow =
                            window.getComputedStyle(entryContent).overflowY !== "visible";

                        if (hasScroll && hasOverflow) {
                            container = entryContent;
                        }
                    }

                    // If no scrollable container found, use body/document
                    if (!container) {
                        container = document.scrollingElement || document.documentElement;
                        isBodyScroll = true;
                    }

                    // Calculate scroll position
                    if (container) {
                        const targetRect = target.getBoundingClientRect();

                        let scrollTop;
                        if (isBodyScroll) {
                            // For body scroll: calculate from top of page
                            const targetTop = targetRect.top + window.scrollY;
                            const viewportHeight = window.innerHeight;
                            scrollTop = targetTop - viewportHeight / 2 + targetRect.height / 2;
                        } else {
                            // For container scroll: calculate relative to container
                            const containerRect = container.getBoundingClientRect();
                            const relativeTop = targetRect.top - containerRect.top + container.scrollTop;
                            scrollTop = relativeTop - container.clientHeight / 2 + targetRect.height / 2;
                        }

                        // Perform scroll
                        container.scrollTo({
                            top: Math.max(0, scrollTop),
                            behavior: "smooth",
                        });
                    }

                    // Wait for scroll to finish and element to be visible
                    const applyHighlight = () => {
                        if (window.highlightTargetTimeoutOut)
                            clearTimeout(window.highlightTargetTimeoutOut);

                        // Clear previous animations from all elements
                        document.querySelectorAll('[style*="animation"]').forEach((el) => {
                            if (el.style.animation.includes("targetZoom")) {
                                el.style.animation = "";
                            }
                        });

                        // Force reflow to ensure animation restarts
                        void target.offsetWidth;

                        // Add highlighting animation
                        target.style.animation = "targetZoom 1.5s ease-out";

                        // Remove animation after completion
                        window.highlightTargetTimeoutOut = setTimeout(() => {
                            target.style.animation = "";
                        }, 1500);
                    };

                    // Detect when scroll ends
                    let observer;
                    let observerTimeout;

                    const onScrollEnd = (event) => {
                        if (observerTimeout) clearTimeout(observerTimeout);
                        observer?.disconnect();

                        // Check if element is visible in viewport
                        const targetRect = target.getBoundingClientRect();
                        let containerRect;

                        if (isBodyScroll) {
                            containerRect = { top: 0, bottom: window.innerHeight };
                        } else {
                            containerRect = container.getBoundingClientRect();
                        }

                        const isVisible =
                            targetRect.top < containerRect.bottom &&
                            targetRect.bottom > containerRect.top;

                        if (isVisible) {
                            // Element is visible, apply highlight
                            if (event) {
                                if (isBodyScroll) {
                                    window.removeEventListener(event, onScrollEnd);
                                } else {
                                    container.removeEventListener(event, onScrollEnd);
                                }
                            }
                            applyHighlight();
                        } else {
                            // Element is not visible yet, use IntersectionObserver
                            if (event) {
                                if (isBodyScroll) {
                                    window.removeEventListener(event, onScrollEnd);
                                } else {
                                    container.removeEventListener(event, onScrollEnd);
                                }
                            }

                            observer = new IntersectionObserver(
                                (entries) => {
                                    entries.forEach((entry) => {
                                        if (entry.isIntersecting) {
                                            observer.disconnect();
                                            applyHighlight();
                                        }
                                    });
                                },
                                {
                                    root: isBodyScroll ? null : container,
                                    threshold: 0.1,
                                }
                            );

                            observer.observe(target);

                            // Cleanup observer after 5 seconds if element never becomes visible
                            observerTimeout = setTimeout(() => {
                                observer?.disconnect();
                            }, 5000);
                        }
                    };

                    if (container) {
                        const scrollTarget = isBodyScroll ? window : container;
                        if ("onscrollend" in document.documentElement) {
                            scrollTarget.addEventListener("scrollend", onScrollEnd("scrollend"));
                        } else {
                            scrollTarget.addEventListener("scroll", onScrollEnd("scroll"));
                        }
                        // Trigger once immediately in case scroll doesn't happen
                        onScrollEnd();
                    }
                }
            }
        });
    });
})();(function setupDetailsAnimation() {
    // Remover listener anterior del documento si existe
    if (window.detailsClickHandler) {
        document.removeEventListener("click", window.detailsClickHandler);
    }

    // Crear el handler
    window.detailsClickHandler = function (e) {
        const details = e.target.closest("details");
        if (!details) return;

        const summary = e.target.closest("summary");
        if (!summary) return;

        const contentWrapper = details.querySelector(".content-wrapper-details");
        if (!contentWrapper) return;

        e.preventDefault();

        if (details.open) {
            // Close with animation
            contentWrapper.classList.add("animating");
            contentWrapper.classList.remove("opening");

            setTimeout(() => {
                details.open = false;
                contentWrapper.classList.remove("animating");
            }, 400);
        } else {
            // Open with animation
            details.open = true;
            contentWrapper.classList.add("animating");

            // Forzar reflow
            contentWrapper.offsetHeight;

            contentWrapper.classList.add("opening");

            setTimeout(() => {
                contentWrapper.classList.remove("animating");
            }, 400);
        }
    };

    // Agregar un solo listener al documento
    document.addEventListener("click", window.detailsClickHandler);

    // Inicializar estado de contenido ya abierto
    document.querySelectorAll("details[open]").forEach((details) => {
        const contentWrapper = details.querySelector(".content-wrapper-details");
        contentWrapper.classList.add("opening");
    });
})();(function setupFloatingElements() {
    // Clean previous event listeners if they exist
    if (window.floatEventListeners) {
        if (window.floatEventListeners.triggerClick) {
            window.floatEventListeners.triggerClick.forEach((item) => {
                item.element.removeEventListener("click", item.handler);
            });
        }
        if (window.floatEventListeners.documentClick) {
            document.removeEventListener("click", window.floatEventListeners.documentClick);
        }
        if (window.floatEventListeners.documentKeydown) {
            document.removeEventListener("keydown", window.floatEventListeners.documentKeydown);
        }
    }

    // Inicializar el objeto para almacenar los event listeners
    window.floatEventListeners = {
        triggerClick: [],
        documentClick: null,
        documentKeydown: null,
        activeFloats: new Set(),
    };

    // Manejar los elementos flotantes
    document.querySelectorAll(".float-trigger").forEach((trigger) => {
        const clickHandler = function () {
            const floatId = this.getAttribute("data-float-id");
            const floatContainer = document.getElementById("float-" + floatId);

            if (!floatContainer) return;

            // If the container is already visible, we close it
            if (floatContainer.classList.contains("visible")) {
                floatContainer.classList.remove("visible");
                window.floatEventListeners.activeFloats.delete(floatId);
                return;
            }

            // Close all floating containers that are open
            document.querySelectorAll(".float-container.visible").forEach((container) => {
                container.classList.remove("visible");
                const openFloatId = container.id.replace("float-", "");
                window.floatEventListeners.activeFloats.delete(openFloatId);
            });

            // Mostrar el contenedor
            floatContainer.classList.add("visible");
            void floatContainer.offsetWidth; // reflow force before measuring
            window.floatEventListeners.activeFloats.add(floatId);

            const triggerRect = this.getBoundingClientRect();
            const parentRect = floatContainer.offsetParent.getBoundingClientRect();

            // Find the scrollable container (entry-content or closest scrollable parent)
            let scrollContainer = this.closest(".entry-content");
            if (!scrollContainer) {
                scrollContainer = this.closest('[style*="overflow"]') || document.documentElement;
            }

            // Get scroll offsets
            const scrollLeft = scrollContainer.scrollLeft || 0;
            const scrollTop = scrollContainer.scrollTop || 0;

            let left = triggerRect.left - parentRect.left + scrollLeft;
            let top = triggerRect.bottom - parentRect.top + scrollTop + 10;

            const floatWidth = floatContainer.offsetWidth;
            const floatHeight = floatContainer.offsetHeight;
            const parentWidth = floatContainer.offsetParent.clientWidth;
            const parentHeight = floatContainer.offsetParent.clientHeight;

            // Ajustar horizontal
            if (left + floatWidth > parentWidth - 10) {
                left = parentWidth - floatWidth - 10;
            }
            if (left < 0) {
                left = 0;
            }

            // Ajustar vertical - considerar tanto el viewport del contenedor con scroll como el viewport de la ventana
            const scrollContainerRect = scrollContainer.getBoundingClientRect();
            const triggerBottomRelativeToScroll = triggerRect.bottom - scrollContainerRect.top;
            const availableSpaceInContainer =
                scrollContainer.clientHeight - triggerBottomRelativeToScroll;

            // También verificar si se sale del viewport de la ventana
            const availableSpaceInWindow = window.innerHeight - triggerRect.bottom;

            // Si el contenedor tiene scroll, usar su espacio disponible, sino usar el de la ventana
            const hasContainerScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;
            const shouldCheckContainer =
                hasContainerScroll && scrollContainer !== document.documentElement;

            let shouldPlaceAbove = false;
            if (shouldCheckContainer) {
                // El contenedor tiene scroll, verificar espacio en el contenedor
                shouldPlaceAbove = availableSpaceInContainer < floatHeight + 50;
            } else {
                // El contenedor no tiene scroll, verificar espacio en la ventana
                shouldPlaceAbove = availableSpaceInWindow < floatHeight + 50;
            }

            if (shouldPlaceAbove) {
                // si no cabe debajo, colócalo arriba del trigger
                top = triggerRect.top - parentRect.top + scrollTop - floatHeight - 10;
            }

            // Asegurar que no se salga por arriba
            const minTop = shouldCheckContainer ? scrollTop + 10 : 10;
            if (top < minTop) {
                top = minTop;
            }

            // Asegurar que no se salga por abajo del viewport de la ventana
            if (!shouldCheckContainer) {
                const maxTop = window.innerHeight - floatHeight - 20;
                const currentTopInViewport = top - scrollTop + parentRect.top;
                if (currentTopInViewport > maxTop) {
                    top = maxTop + scrollTop - parentRect.top;
                }
            }

            floatContainer.style.left = left + "px";
            floatContainer.style.top = top + "px";
        };

        trigger.addEventListener("click", clickHandler);
        window.floatEventListeners.triggerClick.push({
            element: trigger,
            handler: clickHandler,
        });
    });

    // Cerrar los elementos flotantes al hacer clic fuera
    const documentClickHandler = function (e) {
        if (e.target.classList.contains("float-close")) {
            const container = e.target.closest(".float-container");
            if (container) {
                container.classList.remove("visible");
                const floatId = container.id.replace("float-", "");
                window.floatEventListeners.activeFloats.delete(floatId);
            }
        } else if (!e.target.closest(".float-container") && !e.target.closest(".float-trigger")) {
            document.querySelectorAll(".float-container.visible").forEach((container) => {
                container.classList.remove("visible");
                const floatId = container.id.replace("float-", "");
                window.floatEventListeners.activeFloats.delete(floatId);
            });
        }
    };

    document.addEventListener("click", documentClickHandler);
    window.floatEventListeners.documentClick = documentClickHandler;

    // Cerrar con ESC
    const documentKeydownHandler = function (e) {
        if (e.key === "Escape") {
            document.querySelectorAll(".float-container.visible").forEach((container) => {
                container.classList.remove("visible");
                const floatId = container.id.replace("float-", "");
                window.floatEventListeners.activeFloats.delete(floatId);
            });
        }
    };

    document.addEventListener("keydown", documentKeydownHandler);
    window.floatEventListeners.documentKeydown = documentKeydownHandler;

    // Global method to close all floating elements
    window.closeAllFloats = function () {
        document.querySelectorAll(".float-container.visible").forEach((container) => {
            container.classList.remove("visible");
        });
        window.floatEventListeners.activeFloats.clear();
    };
})();
</script><script id="sidebar-data" type="application/json">
[
    "## Tools",
    "## Configuration",
    "## How to set a language selector"
]
</script>